import { db } from "../lib/firebase";
/**
 * @param  {} user
 * Binds Firebase user subscription data stored in Firestore
 */
export async function parseUser(user) {
  const { uid } = user;
  try {
    const subscription = await db
      .collection("users")
      .doc(uid)
      .collection("private")
      .doc("subscription")
      .get();
    console.log(subscription.data());

    return { ...user, ...subscription.data() };
  } catch (e) {
    console.log(e);
    return { ...user, subscriptionType: false };
  }
}
/**
 *
 *
 *
 * @param  {} user
 * Saves name and email of the user to Firestore database
 * The doc id is the uid token
 */
export async function saveUserToFirestore(user) {
  try {
    const { uid, email, displayName: name } = user;
    await db.collection("users").doc(uid).set({ email, name }, { merge: true });
  } catch (e) {
    console.log("An error happened while saving the user to Firestore", e);
  }
}
/**
 *
 *
 *
 *
 * @param  {string} fontName
 * @param  {} user
 *
 * Save to Firestore the unliked font
 * Doc id autogenerated, doc fields: fontName
 *
 * We can't blacklist a font two times because
 * that information is taken into account to show the
 * fonts in future uses
 */
export async function blacklistFont(fontObj, user) {
  const { uid } = user;

  db.collection("users")
    .doc(uid)
    .collection("unlikedFonts")
    .doc(fontObj.family)
    .set({ ...fontObj });
}
/**
 * @param  {Array} fontNames
 * @param  {string} uid
 *Receives an array of arrays [[font1, font2],[]]
 * Save the list of liked fonts to Firestore db
 * TODO: what if the user has already saved the font match?
 */
export async function saveLikedFonts(fontNames, uid) {
  try {
    const likedFontsCollection = db
      .collection("users")
      .doc(uid)
      .collection("likedFonts");
    fontNames.map((likedList) =>
      likedFontsCollection.add({ fontFamilyNames: likedList })
    );
  } catch (e) {
    console.log(
      "An error happened while saving liked font's data to the database"
    );
  }
}
